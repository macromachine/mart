#ifndef __KLEE_SEMU_GENMU_operatorClasses__NumericAndPointerRelational_Base__
#define __KLEE_SEMU_GENMU_operatorClasses__NumericAndPointerRelational_Base__

/**
 * -==== NumericAndPointerRelational_Base.h
 *
 *                LLGenMu LLVM Mutation Tool
 *
 * This file is distributed under the University of Illinois Open Source
 * License. See LICENSE.TXT for details. 
 *  
 * \brief     Generic abstract base class for all non-pointer and pointer relational mutation operator.
 * \details   This abstract class define is extended from the Generic base class. 
 */
 
#include "../GenericMuOpBase.h"

class NumericAndPointerRelational_Base: public GenericMuOpBase
{
  protected:
    /**
     * \brief This method is to be implemented by each relational matching-mutating operator
     * @return true if the pred match, else false. the pred tell the type of comparison (NE, EQ,..)
     */
    inline virtual bool predMatch (llvm::CmpInst::Predicate predToMatch) = 0;
    
    /**
     * \brief This method is to be implemented by each relational matching-mutating operator
     * @return the constant with value 0 of this type
     */
    inline virtual llvm::Constant *getZero (llvm::Value *val) = 0;
    
    /**
     * \brief This method is to be implemented by each relational matching-mutating operator
     * @return predicate for not equal that match with the type of the passed value
     */
    inline virtual llvm::CmpInst::Predicate getNeqPred() = 0;
    
  public:
    bool matchIRs (std::vector<llvm::Value *> const &toMatch, llvmMutationOp const &mutationOp, unsigned pos, MatchUseful &MU, ModuleUserInfos const &MI) 
    {
        llvm::Value *val = toMatch.at(pos);
        if (llvm::CmpInst *cmp = llvm::dyn_cast<llvm::CmpInst>(val))
        {
            if (!(checkCPTypeInIR (mutationOp.getCPType(0), cmp->getOperand(0)) && checkCPTypeInIR (mutationOp.getCPType(1), cmp->getOperand(1))))
                continue;
                    
            if (predMatch(cmp->getPredicate()))
                continue;
                
            ///// TODO TODO TODO
            if (llvm::CmpInst::isIntPredicate(irPred))
            {
                zero = llvm::ConstantInt::get(cmp->getOperand(1)->getType(), 0);
                neqPredHere = mrel_IRrel_Map.at(mICMP_NE);
            }
            else if (llvm::CmpInst::isFPPredicate(irPred))
            {
                zero = llvm::ConstantFP::get(cmp->getOperand(1)->getType(), 0);
                neqPredHere = mrel_IRrel_Map.at(llvm::CmpInst::isOrdered(irPred)? mFCMP_ONE: mFCMP_UNE);
            }
            //else
            //    assert (false && "Invalid Predicate for CMP");
            //?~~~~~
            
            MatchUseful *ptr_mu = MU.getNew();
            if (llvm::isa<llvm::Constant>(cmp->getOperand(0)))    //first oprd
                ptr_mu->appendHLOprdsSource(pos, 0);
            else
                ptr_mu->appendHLOprdsSource(depPosofPos(toMatch, cmp->getOperand(0), pos, true));
            if (llvm::isa<llvm::Constant>(cmp->getOperand(1)))  //second oprd
                ptr_mu->appendHLOprdsSource(pos, 1);
            else
                ptr_mu->appendHLOprdsSource(depPosofPos(toMatch, cmp->getOperand(1), pos,true));
            ptr_mu->appendRelevantIRPos(pos);
            ptr_mu->setHLReturningIRPos(pos);
        }
        return (MU.first() != MU.end());
    }
    
    void prepareCloneIRs (std::vector<llvm::Value *> const &toMatch, unsigned pos,  MatchUseful const &MU, llvmMutationOp::MutantReplacors const &repl, DoReplaceUseful &DRU, ModuleUserInfos const &MI)
    {
        const std::map<enum ExpElemKeys, llvm::CmpInst::Predicate> *mrel_IRrel_Map = getPredRelMap();
        cloneStmtIR (toMatch, DRU.toMatchClone);
        unsigned cmpPos = MU.getRelevantIRPosOf(0);
        std::map<enum ExpElemKeys, llvm::CmpInst::Predicate>::const_iterator map_it = mrel_IRrel_Map->find(repl.first);
        if (map_it != mrel_IRrel_Map->end())
        {   //directly replace the Predicate in case the replacor is also a CMP instruction
            // NO CALL TO doReplacement HERE
            llvm::dyn_cast<llvm::CmpInst>(DRU.toMatchClone[cmpPos])->setPredicate(map_it->second);
            llvm::Value *oprdptr[2];
            oprdptr[0] = llvm::dyn_cast<llvm::User>(DRU.toMatchClone[cmpPos])->getOperand(0);
            oprdptr[1] = llvm::dyn_cast<llvm::User>(DRU.toMatchClone[cmpPos])->getOperand(1);
            llvm::dyn_cast<llvm::User>(DRU.toMatchClone[cmpPos])->setOperand(0, oprdptr[repl.getOprdIndexList()[0]]);
            llvm::dyn_cast<llvm::User>(DUR.toMatchClone[cmpPos])->setOperand(1, oprdptr[repl.getOprdIndexList()[1]]);
            
            DRU.setOrigRelevantIRPos(MU.getRelevantIRPos());
            //\\\\resultMuts.push_back(DRU.toMatchClone); 
        }
        else
        {
            llvm::Value * oprdptr[]={nullptr, nullptr};
            for (int i=0; i < repl.getOprdIndexList().size(); i++)
            {
                if (!(oprdptr[i] = createIfConst (MU.getHLOperandSource(i/*either 0 or 1*/, DRU.toMatchClone)->getType(), repl.getOprdIndexList()[i])))
                {
                    oprdptr[i] = MU.getHLOperandSource(repl.getOprdIndexList()[i], DRU.toMatchClone);
                }
            }
            
            llvm::Constant *zero = getZero(U.getHLOperandSource(1, DRU.toMatchClone));
            llvm::CmpInst::Predicate neqPredHere = getNeqPred();
            DRU.appendHLOprds(oprdptr[0]);
            DRU.appendHLOprds(oprdptr[1]);
            DRU.setOrigRelevantIRPos(MU.getRelevantIRPos());
            DRU.setHLReturnIntoIRPos(cmpPos);
            DRU.setHLReturnIntoOprdIndex(0)
            
            llvm::dyn_cast<llvm::User>(DRU.toMatchClone[cmpPos])->setOperand(1, zero);
            llvm::dyn_cast<llvm::CmpInst>(DRU.toMatchClone[cmpPos])->setPredicate(neqPredHere);
            //\\\\doReplacement (toMatch, resultMuts, repl, DRU.toMatchClone, posOfIRtoRemove, oprdptr[0], oprdptr[1], dumb);
        }
    }
    
    void matchAndReplace (std::vector<llvm::Value *> const &toMatch, llvmMutationOp const &mutationOp, MutantsOfStmt &resultMuts, bool &isDeleted, ModuleUserInfos const &MI)
    {
        MatchUseful mu;
        DoReplaceUseful dru;
        int pos = -1;
        bool stmtDeleted = false;
        for (auto *val:toMatch)
        {
            pos++;
            if (matchIRs (toMatch, mutationOp, pos, mu, MI))
            {
                for (auto &repl: mutationOp.getMutantReplacorsList())
                {
                    if (isDeletion(repl.getExpElemKey()))
                    {
                        doDeleteStmt (toMatch, repl, resultMuts, isDeleted, MI);
                    }
                    else
                    {
                        for (MatchUseful const *ptr_mu = mu.first(); ptr_mu != mu.end(); ptr_mu = ptr_mu->next())
                        {
                            prepareCloneIRs (toMatch, pos, *ptr_mu, repl, dru, MI);
                            try 
                            {
                                dru.getOrigRelevantIRPos();
                            }
                            catch (std::exception& e)
                            {
                                llvm::errs() << "didn't set 'OrigRelevantIRPos': " << e.what();
                            }
                            
                            if (dru.getHLReturnIntoIRPos() < 0)   //the replacer is also reational: already mutated into toMatchClone
                                resultMuts.add(toMatch, toMatchClone, repl, dru.getOrigRelevantIRPos()); 
                            else
                                doReplacement (toMatch, resultMuts, repl, dru.toMatchClone, dru.posOfIRtoRemove, dru.getHLOprdOrNull(0), dru.getHLOprdOrNull(1), 
                                                dru.getHLReturningIRPos(), dru.getOrigRelevantIRPos(), MI, dru.getHLReturnIntoIRPos(), dru.getHLReturnIntoOprdIndex());
                            
                            //make sure to clear 'dru' for the next replcement
                            dru.clearAll();
                        }
                    }
                }
                
                //make sure to clear both 'mu' for the next match
                mu.clearAll (); 
            }
        }
    }
    
  protected:
    std::map<enum ExpElemKeys, llvm::CmpInst::Predicate> * getPredRelMap()
    {
        static std::map<enum ExpElemKeys, llvm::CmpInst::Predicate> mrel_IRrel_Map;
        if (mrel_IRrel_Map.empty())
        {
            typedef std::pair<enum ExpElemKeys, llvm::CmpInst::Predicate> RelPairType;
            mrel_IRrel_Map.insert(RelPairType (mFCMP_FALSE, llvm::CmpInst::FCMP_FALSE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_OEQ, llvm::CmpInst::FCMP_OEQ));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_OGT, llvm::CmpInst::FCMP_OGT));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_OGE, llvm::CmpInst::FCMP_OGE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_OLT, llvm::CmpInst::FCMP_OLT));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_OLE, llvm::CmpInst::FCMP_OLE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_ONE, llvm::CmpInst::FCMP_ONE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_ORD, llvm::CmpInst::FCMP_ORD));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_UNO, llvm::CmpInst::FCMP_UNO));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_UEQ, llvm::CmpInst::FCMP_UEQ));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_UGT, llvm::CmpInst::FCMP_UGT));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_UGE, llvm::CmpInst::FCMP_UGE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_ULT, llvm::CmpInst::FCMP_ULT));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_ULE, llvm::CmpInst::FCMP_ULE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_UNE, llvm::CmpInst::FCMP_UNE));
            mrel_IRrel_Map.insert(RelPairType (mFCMP_TRUE, llvm::CmpInst::FCMP_TRUE));
            mrel_IRrel_Map.insert(RelPairType (mICMP_EQ, llvm::CmpInst::ICMP_EQ));
            mrel_IRrel_Map.insert(RelPairType (mICMP_NE, llvm::CmpInst::ICMP_NE));
            mrel_IRrel_Map.insert(RelPairType (mICMP_UGT, llvm::CmpInst::ICMP_UGT));
            mrel_IRrel_Map.insert(RelPairType (mICMP_UGE, llvm::CmpInst::ICMP_UGE));
            mrel_IRrel_Map.insert(RelPairType (mICMP_ULT, llvm::CmpInst::ICMP_ULT));
            mrel_IRrel_Map.insert(RelPairType (mICMP_ULE, llvm::CmpInst::ICMP_ULE));
            mrel_IRrel_Map.insert(RelPairType (mICMP_SGT, llvm::CmpInst::ICMP_SGT));
            mrel_IRrel_Map.insert(RelPairType (mICMP_SGE, llvm::CmpInst::ICMP_SGE));
            mrel_IRrel_Map.insert(RelPairType (mICMP_SLT, llvm::CmpInst::ICMP_SLT));
            mrel_IRrel_Map.insert(RelPairType (mICMP_SLE, llvm::CmpInst::ICMP_SLE));
            assert (mrel_IRrel_Map.size() == 26 && "Error Inserting some element into mrel_IRrel_Map");
        }
        
        return &mrel_IRrel_Map;
    }
};

#endif //__KLEE_SEMU_GENMU_operatorClasses__NumericAndPointerRelational_Base__
