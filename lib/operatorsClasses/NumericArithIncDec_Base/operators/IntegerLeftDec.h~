#ifndef __KLEE_SEMU_GENMU_operatorClasses__IntegerLeftDec__
#define __KLEE_SEMU_GENMU_operatorClasses__IntegerLeftDec__

/**
 * -==== IntegerLeftDec.h
 *
 *                LLGenMu LLVM Mutation Tool
 *
 * This file is distributed under the University of Illinois Open Source
 * License. See LICENSE.TXT for details. 
 *  
 * \brief     Generic abstract base class for all non-pointer arithmetic left increment mutation operator.
 * \details   This abstract class define is extended from the Generic base class. 
 */
 
#include "../NumericArithIncDec_Base.h"

class IntegerLeftDec: public NumericArithIncDec_Base
{
    protected:
    /**
     * \brief Implement from @see NumericArithIncDec_Base
     */
    inline bool isMyAdd1Sub1(llvm::BinaryOperator *modif, llvm::Constant *constpart, unsigned notloadat01)
    {
        if(modif->getOpcode() == llvm::Instruction::Add) 
        {
            if(llvm::dyn_cast<llvm::ConstantInt>(constpart)->equalsInt(-1))
                return true;
        }
        else
        {
            if(modif->getOpcode() == llvm::Instruction::Sub) 
                if(llvm::dyn_cast<llvm::ConstantInt>(constpart)->equalsInt(1))
                    if (notloadat01 != 0)       //Constants 1 or -1 should always be the right hand oprd
                        return true;
        }
        return false;
    }
    
    /**
     * \brief Implement from @see NumericArithIncDec_Base
     */
    inline bool isLeft_notRight()
    {
        return true;
    }
  
  public:
    llvm::Value * createReplacement (llvm::Value * oprd1_addrOprd, llvm::Value * oprd2_intValOprd, std::vector<llvm::Value *> &replacement, ModuleUserInfos const &MI)
    {
        llvm::IRBuilder<> builder(MI.getContext()); 
        
        //llvm::dyn_cast<llvm::Instruction>(oprd1_addrOprd)->dump();//DEBUG   
        llvm::Value *rawVal = oprd1_addrOprd;
        std::vector<llvm::Value *> seenCasts;
        while (llvm::isa<llvm::CastInst>(oprd1_addrOprd))
        {
            //assert (llvm::dyn_cast<llvm::User>(val)->getNumOperands() == 1);
            //if (llvm::isa<llvm::PtrToIntInst>(oprd1_addrOprd))
            //    break;
            seenCasts.insert(seenCasts.begin(), oprd1_addrOprd);
            oprd1_addrOprd = llvm::dyn_cast<llvm::User>(oprd1_addrOprd)->getOperand(0);
        }
        
        //Assuming that we check before that it was a variable with 'checkCPTypeInIR'
        assert ((llvm::isa<llvm::LoadInst>(oprd1_addrOprd) /*|| llvm::isa<llvm::PtrToIntInst>(oprd1_addrOprd)*/) && "Must be Load Instruction here (assign left hand oprd)");
        
        llvm::Value *changedVal;
        if (seenCasts.empty())
        {
            if (replfirst == mLEFTINC || replfirst == mRIGHTINC)
                changedVal = builder.CreateAdd(oprd1_addrOprd, llvm::ConstantInt::get(oprd1_addrOprd->getType(), 1));
            else if (replfirst == mFLEFTINC || replfirst == mFRIGHTINC)
                changedVal = builder.CreateFAdd(oprd1_addrOprd, llvm::ConstantFP::get(oprd1_addrOprd->getType(), 1.0));
            else if (replfirst == mLEFTDEC || replfirst == mRIGHTDEC)
                changedVal = builder.CreateSub(oprd1_addrOprd, llvm::ConstantInt::get(oprd1_addrOprd->getType(), 1));
            else if (replfirst == mFLEFTDEC || replfirst == mFRIGHTDEC)
                changedVal = builder.CreateFSub(oprd1_addrOprd, llvm::ConstantFP::get(oprd1_addrOprd->getType(), 1.0));
        }
        else
        {
            if (replfirst == mLEFTINC || replfirst == mRIGHTINC || replfirst == mFLEFTINC || replfirst == mFRIGHTINC)
            {
                if (oprd1_addrOprd->getType()->isIntegerTy())
                    changedVal = builder.CreateAdd(oprd1_addrOprd, llvm::ConstantInt::get(oprd1_addrOprd->getType(), 1));
                else if (oprd1_addrOprd->getType()->isFloatingPointTy())
                    changedVal = builder.CreateFAdd(oprd1_addrOprd, llvm::ConstantFP::get(oprd1_addrOprd->getType(), 1.0));
                else
                    assert ("The type is neither integer nor floating point, can't INC");
            }
            else if (replfirst == mLEFTDEC || replfirst == mRIGHTDEC || replfirst == mFLEFTDEC || replfirst == mFRIGHTDEC)
            {
                if (oprd1_addrOprd->getType()->isIntegerTy())
                    changedVal = builder.CreateSub(oprd1_addrOprd, llvm::ConstantInt::get(oprd1_addrOprd->getType(), 1));
                else if (oprd1_addrOprd->getType()->isFloatingPointTy())
                    changedVal = builder.CreateFSub(oprd1_addrOprd, llvm::ConstantFP::get(oprd1_addrOprd->getType(), 1.0));
                else
                    assert ("The type is neither integer nor floating point, can't DEC");
            }
        }
        
        if (!llvm::dyn_cast<llvm::Constant>(changedVal))
            replacement.push_back(changedVal);
        //llvm::dyn_cast<llvm::Instruction>(changedVal)->dump();//DEBUG
        llvm::Value *storeit = llvm::dyn_cast<llvm::User>(oprd1_addrOprd)->getOperand(0);  //get the address where the data comes from (for store)
        assert(changedVal->getType()->getPrimitiveSizeInBits() && "Must be primitive here");
        storeit = builder.CreateAlignedStore(changedVal, storeit, changedVal->getType()->getPrimitiveSizeInBits()/8);       //the val here is primitive
        replacement.push_back(storeit);
        if (isLeft_notRight())
        {
            if (!seenCasts.empty())
            {
                std::vector<llvm::Value *> copySeenCasts;
                cloneStmtIR (seenCasts, copySeenCasts);
                llvm::dyn_cast<llvm::User>(copySeenCasts.front())->setOperand(0, changedVal);
                replacement.insert(replacement.end(), copySeenCasts.begin(), copySeenCasts.end());
                return replacement.back();
            }
            return changedVal;
        }
        else
        {
            return rawVal;
        }
    }   
};

#endif //__KLEE_SEMU_GENMU_operatorClasses__IntegerLeftDec__
