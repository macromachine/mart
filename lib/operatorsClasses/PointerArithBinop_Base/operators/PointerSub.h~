#ifndef __KLEE_SEMU_GENMU_operatorClasses__PointerSub__
#define __KLEE_SEMU_GENMU_operatorClasses__PointerSub__

/**
 * -==== PointerSub.h
 *
 *                LLGenMu LLVM Mutation Tool
 *
 * This file is distributed under the University of Illinois Open Source
 * License. See LICENSE.TXT for details. 
 *  
 * \brief     class for mutation operator that match and replace pointer add operation (pointer + integer).
 */
 
#include "../PointerArithBinop_Base.h"

class PointerSub: public PointerArithBinop_Base
{
  protected:
    /**
     * \brief Implements from PointerArithBinop_Base
     */
    inline bool checkIntPartConst(llvm::ConstantInt * constIndxVal)
    {
        return constIndxVal->isNegative();
    }
    
    /**
     * \brief Implements from PointerArithBinop_Base
     */
    inline bool checkIntPartExp(llvm::Instruction *tmpI)
    {
        return (tmpI->getOpcode() == llvm::Instruction::Sub || tmpI->getOpcode() == llvm::Instruction::FSub);
    }
    
  public:
    llvm::Value * createReplacement (llvm::Value * oprd1_addrOprd, llvm::Value * oprd2_intValOprd, std::vector<llvm::Value *> &replacement, ModuleUserInfos const &MI)
    {
        llvm::IRBuilder<> builder(MI.getContext());
        llvm::Value *valtmp = builder.CreateNeg(oprd2_intValOprd);
        if (!llvm::dyn_cast<llvm::Constant>(valtmp))
            replacement.push_back(valtmp);
        llvm::Value *addsub_gep = builder.CreateInBoundsGEP(nullptr, oprd1_addrOprd, valtmp);
        if (!llvm::dyn_cast<llvm::Constant>(addsub_gep))
            replacement.push_back(addsub_gep);
        return addsub_gep;
    }  
};

#endif //__KLEE_SEMU_GENMU_operatorClasses__PointerSub__
